# frozen_string_literal: true
require_relative "exclude_strategy"
require_relative "money"
require "ostruct"
require "json"

module SquareApiClient
# Defines how discounts are automatically applied to a set of items that match the
#  pricing rule
#  during the active time period.
  class CatalogPricingRule
  # @return [String] User-defined name for the pricing rule. For example, "Buy one get one
#  free" or "10% off".
    attr_reader :name
  # @return [Array<String>] A list of unique IDs for the catalog time periods when
#  this pricing rule is in effect. If left unset, the pricing rule is always
#  in effect.
    attr_reader :time_period_ids
  # @return [String] Unique ID for the `CatalogDiscount` to take off
#  the price of all matched items.
    attr_reader :discount_id
  # @return [String] Unique ID for the `CatalogProductSet` that will be matched by this rule. A match
#  rule
#  matches within the entire cart, and can match multiple times. This field will
#  always be set.
    attr_reader :match_products_id
  # @return [String] __Deprecated__: Please use the `exclude_products_id` field to apply
#  an exclude set instead. Exclude sets allow better control over quantity
#  ranges and offer more flexibility for which matched items receive a discount.
#  `CatalogProductSet` to apply the pricing to.
#  An apply rule matches within the subset of the cart that fits the match rules
#  (the match set).
#  An apply rule can only match once in the match set.
#  If not supplied, the pricing will be applied to all products in the match set.
#  Other products retain their base price, or a price generated by other rules.
    attr_reader :apply_products_id
  # @return [String] `CatalogProductSet` to exclude from the pricing rule.
#  An exclude rule matches within the subset of the cart that fits the match rules
#  (the match set).
#  An exclude rule can only match once in the match set.
#  If not supplied, the pricing will be applied to all products in the match set.
#  Other products retain their base price, or a price generated by other rules.
    attr_reader :exclude_products_id
  # @return [String] Represents the date the Pricing Rule is valid from. Represented in RFC 3339
#  full-date format (YYYY-MM-DD).
    attr_reader :valid_from_date
  # @return [String] Represents the local time the pricing rule should be valid from. Represented in
#  RFC 3339 partial-time format
#  (HH:MM:SS). Partial seconds will be truncated.
    attr_reader :valid_from_local_time
  # @return [String] Represents the date the Pricing Rule is valid until. Represented in RFC 3339
#  full-date format (YYYY-MM-DD).
    attr_reader :valid_until_date
  # @return [String] Represents the local time the pricing rule should be valid until. Represented in
#  RFC 3339 partial-time format
#  (HH:MM:SS). Partial seconds will be truncated.
    attr_reader :valid_until_local_time
  # @return [SquareApiClient::ExcludeStrategy] If an `exclude_products_id` was given, controls which subset of matched
#  products is excluded from any discounts.
#  Default value: `LEAST_EXPENSIVE`
#  See [ExcludeStrategy](#type-excludestrategy) for possible values
    attr_reader :exclude_strategy
  # @return [SquareApiClient::Money] The minimum order subtotal (before discounts or taxes are applied)
#  that must be met before this rule may be applied.
    attr_reader :minimum_order_subtotal_money
  # @return [Array<String>] A list of IDs of customer groups, the members of which are eligible for
#  discounts specified in this pricing rule.
#  Notice that a group ID is generated by the Customers API.
#  If this field is not set, the specified discount applies to matched products
#  sold to anyone whether the buyer
#  has a customer profile created or not. If this `customer_group_ids_any` field is
#  set, the specified discount
#  applies only to matched products sold to customers belonging to the specified
#  customer groups.
    attr_reader :customer_group_ids_any
  # @return [OpenStruct] Additional properties unmapped to the current class definition
    attr_reader :additional_properties
  # @return [Object] 
    attr_reader :_field_set
    protected :_field_set

    OMIT = Object.new

    # @param name [String] User-defined name for the pricing rule. For example, "Buy one get one
#  free" or "10% off".
    # @param time_period_ids [Array<String>] A list of unique IDs for the catalog time periods when
#  this pricing rule is in effect. If left unset, the pricing rule is always
#  in effect.
    # @param discount_id [String] Unique ID for the `CatalogDiscount` to take off
#  the price of all matched items.
    # @param match_products_id [String] Unique ID for the `CatalogProductSet` that will be matched by this rule. A match
#  rule
#  matches within the entire cart, and can match multiple times. This field will
#  always be set.
    # @param apply_products_id [String] __Deprecated__: Please use the `exclude_products_id` field to apply
#  an exclude set instead. Exclude sets allow better control over quantity
#  ranges and offer more flexibility for which matched items receive a discount.
#  `CatalogProductSet` to apply the pricing to.
#  An apply rule matches within the subset of the cart that fits the match rules
#  (the match set).
#  An apply rule can only match once in the match set.
#  If not supplied, the pricing will be applied to all products in the match set.
#  Other products retain their base price, or a price generated by other rules.
    # @param exclude_products_id [String] `CatalogProductSet` to exclude from the pricing rule.
#  An exclude rule matches within the subset of the cart that fits the match rules
#  (the match set).
#  An exclude rule can only match once in the match set.
#  If not supplied, the pricing will be applied to all products in the match set.
#  Other products retain their base price, or a price generated by other rules.
    # @param valid_from_date [String] Represents the date the Pricing Rule is valid from. Represented in RFC 3339
#  full-date format (YYYY-MM-DD).
    # @param valid_from_local_time [String] Represents the local time the pricing rule should be valid from. Represented in
#  RFC 3339 partial-time format
#  (HH:MM:SS). Partial seconds will be truncated.
    # @param valid_until_date [String] Represents the date the Pricing Rule is valid until. Represented in RFC 3339
#  full-date format (YYYY-MM-DD).
    # @param valid_until_local_time [String] Represents the local time the pricing rule should be valid until. Represented in
#  RFC 3339 partial-time format
#  (HH:MM:SS). Partial seconds will be truncated.
    # @param exclude_strategy [SquareApiClient::ExcludeStrategy] If an `exclude_products_id` was given, controls which subset of matched
#  products is excluded from any discounts.
#  Default value: `LEAST_EXPENSIVE`
#  See [ExcludeStrategy](#type-excludestrategy) for possible values
    # @param minimum_order_subtotal_money [SquareApiClient::Money] The minimum order subtotal (before discounts or taxes are applied)
#  that must be met before this rule may be applied.
    # @param customer_group_ids_any [Array<String>] A list of IDs of customer groups, the members of which are eligible for
#  discounts specified in this pricing rule.
#  Notice that a group ID is generated by the Customers API.
#  If this field is not set, the specified discount applies to matched products
#  sold to anyone whether the buyer
#  has a customer profile created or not. If this `customer_group_ids_any` field is
#  set, the specified discount
#  applies only to matched products sold to customers belonging to the specified
#  customer groups.
    # @param additional_properties [OpenStruct] Additional properties unmapped to the current class definition
    # @return [SquareApiClient::CatalogPricingRule]
    def initialize(name: OMIT, time_period_ids: OMIT, discount_id: OMIT, match_products_id: OMIT, apply_products_id: OMIT, exclude_products_id: OMIT, valid_from_date: OMIT, valid_from_local_time: OMIT, valid_until_date: OMIT, valid_until_local_time: OMIT, exclude_strategy: OMIT, minimum_order_subtotal_money: OMIT, customer_group_ids_any: OMIT, additional_properties: nil)
      @name = name if name != OMIT
      @time_period_ids = time_period_ids if time_period_ids != OMIT
      @discount_id = discount_id if discount_id != OMIT
      @match_products_id = match_products_id if match_products_id != OMIT
      @apply_products_id = apply_products_id if apply_products_id != OMIT
      @exclude_products_id = exclude_products_id if exclude_products_id != OMIT
      @valid_from_date = valid_from_date if valid_from_date != OMIT
      @valid_from_local_time = valid_from_local_time if valid_from_local_time != OMIT
      @valid_until_date = valid_until_date if valid_until_date != OMIT
      @valid_until_local_time = valid_until_local_time if valid_until_local_time != OMIT
      @exclude_strategy = exclude_strategy if exclude_strategy != OMIT
      @minimum_order_subtotal_money = minimum_order_subtotal_money if minimum_order_subtotal_money != OMIT
      @customer_group_ids_any = customer_group_ids_any if customer_group_ids_any != OMIT
      @additional_properties = additional_properties
      @_field_set = { "name": name, "time_period_ids": time_period_ids, "discount_id": discount_id, "match_products_id": match_products_id, "apply_products_id": apply_products_id, "exclude_products_id": exclude_products_id, "valid_from_date": valid_from_date, "valid_from_local_time": valid_from_local_time, "valid_until_date": valid_until_date, "valid_until_local_time": valid_until_local_time, "exclude_strategy": exclude_strategy, "minimum_order_subtotal_money": minimum_order_subtotal_money, "customer_group_ids_any": customer_group_ids_any }.reject do | _k, v |
  v == OMIT
end
    end
# Deserialize a JSON object to an instance of CatalogPricingRule
    #
    # @param json_object [String] 
    # @return [SquareApiClient::CatalogPricingRule]
    def self.from_json(json_object:)
      struct = JSON.parse(json_object, object_class: OpenStruct)
      parsed_json = JSON.parse(json_object)
      name = parsed_json["name"]
      time_period_ids = parsed_json["time_period_ids"]
      discount_id = parsed_json["discount_id"]
      match_products_id = parsed_json["match_products_id"]
      apply_products_id = parsed_json["apply_products_id"]
      exclude_products_id = parsed_json["exclude_products_id"]
      valid_from_date = parsed_json["valid_from_date"]
      valid_from_local_time = parsed_json["valid_from_local_time"]
      valid_until_date = parsed_json["valid_until_date"]
      valid_until_local_time = parsed_json["valid_until_local_time"]
      exclude_strategy = parsed_json["exclude_strategy"]
      unless parsed_json["minimum_order_subtotal_money"].nil?
        minimum_order_subtotal_money = parsed_json["minimum_order_subtotal_money"].to_json
        minimum_order_subtotal_money = SquareApiClient::Money.from_json(json_object: minimum_order_subtotal_money)
      else
        minimum_order_subtotal_money = nil
      end
      customer_group_ids_any = parsed_json["customer_group_ids_any"]
      new(
        name: name,
        time_period_ids: time_period_ids,
        discount_id: discount_id,
        match_products_id: match_products_id,
        apply_products_id: apply_products_id,
        exclude_products_id: exclude_products_id,
        valid_from_date: valid_from_date,
        valid_from_local_time: valid_from_local_time,
        valid_until_date: valid_until_date,
        valid_until_local_time: valid_until_local_time,
        exclude_strategy: exclude_strategy,
        minimum_order_subtotal_money: minimum_order_subtotal_money,
        customer_group_ids_any: customer_group_ids_any,
        additional_properties: struct
      )
    end
# Serialize an instance of CatalogPricingRule to a JSON object
    #
    # @return [String]
    def to_json
      @_field_set&.to_json
    end
# Leveraged for Union-type generation, validate_raw attempts to parse the given
#  hash and check each fields type against the current object's property
#  definitions.
    #
    # @param obj [Object] 
    # @return [Void]
    def self.validate_raw(obj:)
      obj.name&.is_a?(String) != false || raise("Passed value for field obj.name is not the expected type, validation failed.")
      obj.time_period_ids&.is_a?(Array) != false || raise("Passed value for field obj.time_period_ids is not the expected type, validation failed.")
      obj.discount_id&.is_a?(String) != false || raise("Passed value for field obj.discount_id is not the expected type, validation failed.")
      obj.match_products_id&.is_a?(String) != false || raise("Passed value for field obj.match_products_id is not the expected type, validation failed.")
      obj.apply_products_id&.is_a?(String) != false || raise("Passed value for field obj.apply_products_id is not the expected type, validation failed.")
      obj.exclude_products_id&.is_a?(String) != false || raise("Passed value for field obj.exclude_products_id is not the expected type, validation failed.")
      obj.valid_from_date&.is_a?(String) != false || raise("Passed value for field obj.valid_from_date is not the expected type, validation failed.")
      obj.valid_from_local_time&.is_a?(String) != false || raise("Passed value for field obj.valid_from_local_time is not the expected type, validation failed.")
      obj.valid_until_date&.is_a?(String) != false || raise("Passed value for field obj.valid_until_date is not the expected type, validation failed.")
      obj.valid_until_local_time&.is_a?(String) != false || raise("Passed value for field obj.valid_until_local_time is not the expected type, validation failed.")
      obj.exclude_strategy&.is_a?(SquareApiClient::ExcludeStrategy) != false || raise("Passed value for field obj.exclude_strategy is not the expected type, validation failed.")
      obj.minimum_order_subtotal_money.nil? || SquareApiClient::Money.validate_raw(obj: obj.minimum_order_subtotal_money)
      obj.customer_group_ids_any&.is_a?(Array) != false || raise("Passed value for field obj.customer_group_ids_any is not the expected type, validation failed.")
    end
  end
end